1. 로그 보면 fetch를 하긴 하는데, 이 데이터가 들어가질 않네. 아마도 api를 통해 받아오는 데이터의 위치를 변경해줘야 할 것 같음. 현재는 app.js에 있으니 체크.

2. ADD해서 보낸 데이터들 형태가 [{}],[{}],[{}] 이런 형태임. 하나의 배열 안에 모든 객체가 있는게 아니라, 각각의 객체가 각각의 배열로 선언된 형태. 입력형태의 문제인 것 같으니 수정 필요.

3. isTrue값이 1일때 0으로 바꾸는 것은 문제없이 가능. filter해서 나온 것이 아예 빈 배열인 경우, 어떻게 UNDONE처리할 것인지 고민.

4. 기본데이터가 있고, 그 데이터를 기반으로 해서 추가/삭제하는 형태로 진행해야 할 것 같은데... 일단 그냥 빈 배열에 데이터를 추가하는것만 가능하니, 아예 기본데이터를 넣어둔 배열을 바탕으로 추가/삭제 진행하도록 정의해보자.

5. 중복감지 안됨. 아마도 배열이 나뉘어 있기 때문인 듯 함.








A.
1. 데이터 형식 변경하여 fix
2. 상동

5. json server의 경우 post를 하면 기본적으로 id를 생성해서 넣어줌. 이는 관계형 DB라서 어쩔 수 없음. 현재처럼 무의미한 id대신에 id를 생성하여 넣어주는 생성자를 정의해서 사용하자.
- ID의 경우 Dash를 사용하라. REST API를 활용하기 위해서는 어차피 URL에 데이터를 넣어줘야 하는데, Underscore는 URL에서는 사용하지 않음.
- ID가 NaN 띄우면 json server가 새로 숫자를 부여해줌.
- id: 텍스트 는 허용됨.

  {
    "id": "02/26-Af-Co",
    "date": "02/26",
    "time": "Afternoon",
    "type": "Condition",
    "isTrue": 1
  },
  {
    "id": "02/26-Ev-Co",
    "date": "02/26",
    "time": "Evening",
    "type": "Condition",
    "isTrue": 1
  },

  dispatch(addTask({id: today-time.slice(0,2)-item.type.slice(0,2),date: today, time: time, type: item.type, isTrue: 1}));

  id: YYYYMMDD + Time + Type
  id: 20210226 + 1 + 01

텍스트 형태로 넣어도 되고, 숫자를 임의부여해서 넣어도 될 듯.
성능은 숫자형이 훨씬 나아보이긴 하는데.






4. 기본 데이터는 어차피 DB파일에 넣으면 알아서 인식하니까, 사용자마다 템플릿 DB를 생성하도록 프로그래밍하면 해결되는 문제 아닌가?



// 기본개념

// 프로젝트의 상태에 변화를 일으키는 것을 액션이라고 함.

// 상태(state)에 변화가 필요하면 액션이란 것이 발생한다. 이는 하나의 객체. 액션 객체는 type필드를 가지고 있으며, 이 값이 액션 객체의 이름.

// 액션 생성 함수(action creator)는 액션 객체를 만들어주는 함수이다.
// /actions/tasks.js

// createAction으로 액션을 만들면 액션에 필요한 추가 데이터는 payload라는 이름을 사용.

// 리듀서는 변화를 일으키는 함수, 사용자가 액션 객체를 발생시키면 리듀서가 현재 상태와 전달받은 액션 객체를 파라미터로 받아온다. 그리고 두 값을 참고하여 새로운 상태를 만들어서 반환한다.
//

// 디스패치(dispatch)는 '액션을 발생시키는 것', dispatch(action)형태로 액션 객체를 파라미터로 넣어서 호출. 이 함수가 호출되면 스토어는 리듀서 함수를 실행해 새로운 상태(state)를 생성

// 구독(subscribe) 함수 안에 리스너 함수를 파라미터로 넣어서 호출해 주면, 해당하는 리스너 함수가 액션이 디스패치되어 상태가 업데이트될때마다 호출된다.

// useSelector Hook을 사용하면 Redux의 상태를 조회할 수 있다.
// const 결과 = useSelector(상태 선택 함수 ex: state => state.counter.number)

// useDispatch Hook은 컴포넌트 내부에서 스토어의 내장 함수 dispatch를 사용할 수 있게 해준다.
// const dispatch = usdDispatch();
// dispatch({type: 'SAMPLE_ACTION'});

// 컴포넌트 성능을 최적화하고자 한다면 useCallback으로 액션을 디스패치하는 함수를 감싸준다.

// ======================================================================
// 동작의도:
// redux를 이용하여 데이터를 일괄 로드 후 일괄 적용(현재는 각 아이콘에서 하나하나 storage에서 데이터를 받아 처리)

// 기본설계(임시):
// redux 기본패턴(actions와 reducers, constants를 분리) 이용(cf: Ducks구조: Action Type, Action Creator, Reducer를 하나에 몰아서 다 작성하는 구조(module이라고 함))

// 기본동작(예정):
// ADD_TASK(임시) => state 중 isTrue값 1 대입
// REMOVE_TASK(임시) => state 중 isTrue값 0 대입

// ======================================================================
// Q.
// 현재 데이터를 저장하는 구조 [[key, {...value}],[key, {...value}],[key, {...value}], ...]는 그대로 활용할 수 있는지, 안된다면 어떻게 바꿔야 하는지?

// dispatch를 손대는 부분의 현재의 item데이터는 list.js에서 불러오는 데이터. 이 데이터에 손을 대봤자 아무런 의미가 없는데.

// 매개변수 위치가 변경되면 에러남. sonalint 노란줄은 무시해라.